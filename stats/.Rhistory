scale_x_continuous(limits=c(0,2), name="age", breaks = c(0:2), labels = c(3:5)) +
scale_y_continuous(limits = c(0, 1), name="P in favor of preferred object")+
facet_grid(~world)+
theme_few()
prefPostPredConSame%>%
summarise(mean_int = mean(pref_int),
mean_slope = mean(pref_slope))
a <- prefPostPredConSame2%>%
summarise(mean_int = mean(pref_int),
mean_slope = mean(pref_slope))%>%
expand(y = plogis(mean_int + mean_slope * x_plot))%>%
mutate(x = x_plot,
world = "2 objects")
b <- prefPostPredConSame%>%
summarise(mean_int = mean(pref_int),
mean_slope = mean(pref_slope))%>%
expand(y = plogis(mean_int + mean_slope * x_plot))%>%
mutate(x = x_plot,
world = "3 objects")
c <- bind_rows(a,b)
ggplot(x) +
geom_line(aes(x_plot, y_plot, group = iteration), col = "grey", alpha = 0.2) +
geom_ribbon(data = x_mean, aes(x =x_plot, ymin = ci_lower, ymax = ci_upper), fill = "darkgreen", alpha = 0.3) +
geom_line(data = x_mean, aes(x_plot, mean), col = "black") +
geom_line(data = c, aes(x, y), col = "red") +
scale_x_continuous(limits=c(0,2), name="age", breaks = c(0:2), labels = c(3:5)) +
scale_y_continuous(limits = c(0, 1), name="P in favor of preferred object")+
facet_grid(~world)+
theme_few()
ggplot(plot_post_data) +
geom_line(aes(x_plot, y_plot, group = iteration), col = "grey", alpha = 0.2) +
geom_ribbon(data = plot_post_data_mean, aes(x =x_plot, ymin = ci_lower, ymax = ci_upper), fill = "darkgreen", alpha = 0.3) +
geom_line(data = plot_post_data_mean, aes(x_plot, mean), col = "black") +
scale_x_continuous(limits=c(0,2), name="age", breaks = c(0:2), labels = c(3:5)) +
scale_y_continuous(limits = c(0, 1), name="P in favor of preferred object")+
facet_grid(alignment~condition)+
theme_few()
ggplot(data = pref_post, aes(x = value, fill = chain)) +
geom_density(alpha = 0.3)+
facet_grid(Parameter ~ alignment*condition)+
theme_few()
postPred
pref_data
rsaUtils <- '
var all_objects = [
{ shape: "triangle", id:1, location: 1},
{ shape: "triangle", id:2, location: 2},
{ shape: "circle", id:1, location: 2}
]
var prior_objects = [
{ shape: "triangle", id:1, location: 1},
{ shape: "circle", id:1, location: 2}
]
var labels = ["dax","wug"]
var lexicon1 = function(utterance, obj){
utterance.label == "dax" ? obj.shape == "triangle" :
utterance.label == "wug" ? obj.shape == "circle" :
true
}
var lexicon2 = function(utterance, obj){
utterance.label == "dax" ? obj.shape == "circle" :
utterance.label == "wug" ? obj.shape == "triangle" :
true
}
var lexiconObjects = {
"dax = triangle": {
triangle: "dax", circle: "wug"
},
"dax = circle": {
triangle: "wug", circle: "dax"
},
}
var lexiconObject = {
"dax = triangle": lexicon1,
"dax = circle" : lexicon2
}
var point = function(utterance, obj){
return obj.location == utterance.point
}
var utterancePrior = function(obj, lexiconName){
var locationsWithShape = _.map(_.filter(all_objects, {shape: obj.shape}), "location")
var point = uniformDraw(locationsWithShape)
var label = lexiconObjects[lexiconName][obj.shape]
return {label: label, point: point}
}
var LexiconPrior = Categorical({vs: ["dax = triangle","dax = circle" ], ps: [1, 1]})
'
modelPredWebppl <- '
var levels = function(df, label){
return _.uniq(_.map(df, label));
}
var prefData = filter(dataFromR, {experiment: "preference"})
var infData = filter(dataFromR, {experiment: "informativeness"})
// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.1)
var all_conditions = levels(prefData, "condition")
//var priorProbs = []
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
var inf_priorProbs = [.5, .5, .5]
var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
inf_priorProbs, speakerOptimality)
observe(rsaPredictions, row.correct)
}, infData)
var pref_params = map(function(cndtn){
var conditionData = filter(prefData, {condition: cndtn})
var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
var priorProbs= [1-priorReg, priorReg]
var priorPredictions = Infer({method: "enumerate", model: function(){
var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
return obj.shape == "circle" ? 1 : 0
}})
observe(priorPredictions, row.correct)
// display(JSON.stringify(priorReg))
}, conditionData)
return {pref_int, pref_slope, condition: cndtn}
}, all_conditions)
var diff_speaker_params = filter(pref_params,
{condition: "different_speaker"})[0]
var same_speaker_params = filter(pref_params,
{condition: "same_speaker"})[0]
var predictions_by_age = map(function(age_bin){
var speakerOptimality = so_int  + so_slope * age_bin
var diff_priorReg = logistic(diff_speaker_params.pref_int +
diff_speaker_params.pref_slope * age_bin)
var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]
var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent, speakerOptimality))
var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
var same_priorReg = logistic(same_speaker_params.pref_int +
same_speaker_params.pref_slope * age_bin)
var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]
var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]
var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))
var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))
return extend(diff_speaker_params, same_speaker_params, {
diff_priorReg,
same_priorReg,
speakerOptimality,
rsaPredictions_diff_cong,
rsaPredictions_diff_incong,
rsaPredictions_same_cong,
rsaPredictions_same_incong,
age_bin,
so_slope,
so_int
})
}, binned_age_range)
return predictions_by_age
}
'
model_pred<- webppl(
program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
data = pre_data,
data_var = "dataFromR",
model_var = "model",
chains = 1,
cores = 1,
inference_opts = list(method = "MCMC", samples = 20, burn = 1, verbose = T)
)
model_pred<- webppl(
program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
data = pre_data,
data_var = "dataFromR",
model_var = "model",
chains = 1,
cores = 1,
inference_opts = list(method = "MCMC", samples = 20, burn = 1, verbose = T)
)
modelPredWebppl <- '
var levels = function(df, label){
return _.uniq(_.map(df, label));
}
var prefData = filter(dataFromR, {experiment: "preference"})
var infData = filter(dataFromR, {experiment: "informativeness"})
// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.1)
var all_conditions = levels(prefData, "condition")
//var priorProbs = []
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
var inf_priorProbs = [.5, .5, .5]
var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
inf_priorProbs, speakerOptimality)
observe(rsaPredictions, row.correct)
}, infData)
var pref_params = map(function(cndtn){
var conditionData = filter(prefData, {condition: cndtn})
var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
var priorProbs= [1-priorReg, priorReg]
var priorPredictions = Infer({method: "enumerate", model: function(){
var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
return obj.shape == "circle" ? 1 : 0
}})
observe(priorPredictions, row.correct)
// display(JSON.stringify(priorReg))
}, conditionData)
return {pref_int, pref_slope, condition: cndtn}
}, all_conditions)
var diff_speaker_params = filter(pref_params,
{condition: "different_speaker"})[0]
var same_speaker_params = filter(pref_params,
{condition: "same_speaker"})[0]
var predictions_by_age = map(function(age_bin){
var speakerOptimality = so_int  + so_slope * age_bin
var diff_priorReg = logistic(diff_speaker_params.pref_int +
diff_speaker_params.pref_slope * age_bin)
var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]
var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent, speakerOptimality))
var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
var same_priorReg = logistic(same_speaker_params.pref_int +
same_speaker_params.pref_slope * age_bin)
var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]
var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]
var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))
var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))
return extend(diff_speaker_params, same_speaker_params, {
diff_priorReg,
same_priorReg,
speakerOptimality,
rsaPredictions_diff_cong,
rsaPredictions_diff_incong,
rsaPredictions_same_cong,
rsaPredictions_same_incong,
age_bin,
//  so_slope,
//  so_int
})
}, binned_age_range)
return predictions_by_age
}
'
model_pred<- webppl(
program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
data = pre_data,
data_var = "dataFromR",
model_var = "model",
chains = 1,
cores = 1,
inference_opts = list(method = "MCMC", samples = 20, burn = 1, verbose = T)
)
modelPredWebppl <- '
var levels = function(df, label){
return _.uniq(_.map(df, label));
}
var prefData = filter(dataFromR, {experiment: "preference"})
var infData = filter(dataFromR, {experiment: "informativeness"})
// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.1)
var all_conditions = levels(prefData, "condition")
//var priorProbs = []
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
var inf_priorProbs = [.5, .5, .5]
var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
inf_priorProbs, speakerOptimality)
observe(rsaPredictions, row.correct)
}, infData)
var pref_params = map(function(cndtn){
var conditionData = filter(prefData, {condition: cndtn})
var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
var priorProbs= [1-priorReg, priorReg]
var priorPredictions = Infer({method: "enumerate", model: function(){
var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
return obj.shape == "circle" ? 1 : 0
}})
observe(priorPredictions, row.correct)
// display(JSON.stringify(priorReg))
}, conditionData)
return {pref_int, pref_slope, condition: cndtn}
}, all_conditions)
var diff_speaker_params = filter(pref_params,
{condition: "different_speaker"})[0]
var same_speaker_params = filter(pref_params,
{condition: "same_speaker"})[0]
var predictions_by_age = map(function(age_bin){
var speakerOptimality = so_int  + so_slope * age_bin
var diff_priorReg = logistic(diff_speaker_params.pref_int +
diff_speaker_params.pref_slope * age_bin)
var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]
var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent, speakerOptimality))
var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
var same_priorReg = logistic(same_speaker_params.pref_int +
same_speaker_params.pref_slope * age_bin)
var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]
var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]
var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))
var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))
return extend(
//diff_speaker_params, same_speaker_params,
{
diff_priorReg,
same_priorReg,
speakerOptimality,
rsaPredictions_diff_cong,
rsaPredictions_diff_incong,
rsaPredictions_same_cong,
rsaPredictions_same_incong,
age_bin,
//  so_slope,
//  so_int
})
}, binned_age_range)
return predictions_by_age
}
'
model_pred<- webppl(
program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
data = pre_data,
data_var = "dataFromR",
model_var = "model",
chains = 1,
cores = 1,
inference_opts = list(method = "MCMC", samples = 20, burn = 1, verbose = T)
)
modelPredWebppl <- '
var levels = function(df, label){
return _.uniq(_.map(df, label));
}
var prefData = filter(dataFromR, {experiment: "preference"})
var infData = filter(dataFromR, {experiment: "informativeness"})
// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.1)
var all_conditions = levels(prefData, "condition")
//var priorProbs = []
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
var inf_priorProbs = [.5, .5, .5]
var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
inf_priorProbs, speakerOptimality)
observe(rsaPredictions, row.correct)
}, infData)
var pref_params = map(function(cndtn){
var conditionData = filter(prefData, {condition: cndtn})
var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
var priorProbs= [1-priorReg, priorReg]
var priorPredictions = Infer({method: "enumerate", model: function(){
var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
return obj.shape == "circle" ? 1 : 0
}})
observe(priorPredictions, row.correct)
// display(JSON.stringify(priorReg))
}, conditionData)
return {pref_int, pref_slope, condition: cndtn}
}, all_conditions)
var diff_speaker_params = filter(pref_params,
{condition: "different_speaker"})[0]
var same_speaker_params = filter(pref_params,
{condition: "same_speaker"})[0]
var predictions_by_age = map(function(age_bin){
var speakerOptimality = so_int  + so_slope * age_bin
var diff_priorReg = logistic(diff_speaker_params.pref_int +
diff_speaker_params.pref_slope * age_bin)
var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]
var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent, speakerOptimality))
var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
var same_priorReg = logistic(same_speaker_params.pref_int +
same_speaker_params.pref_slope * age_bin)
var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]
var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]
var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))
var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))
return extend(
//diff_speaker_params, same_speaker_params,
{
// diff_priorReg,
//  same_priorReg,
//  speakerOptimality,
rsaPredictions_diff_cong,
rsaPredictions_diff_incong,
rsaPredictions_same_cong,
rsaPredictions_same_incong,
age_bin,
//  so_slope,
//  so_int
})
}, binned_age_range)
return predictions_by_age
}
'
model_pred<- webppl(
program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
data = pre_data,
data_var = "dataFromR",
model_var = "model",
chains = 1,
cores = 1,
inference_opts = list(method = "MCMC", samples = 20, burn = 1, verbose = T)
)
modelPredWebppl <- '
var levels = function(df, label){
return _.uniq(_.map(df, label));
}
var prefData = filter(dataFromR, {experiment: "preference"})
var infData = filter(dataFromR, {experiment: "informativeness"})
// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.1)
var all_conditions = levels(prefData, "condition")
//var priorProbs = []
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
var inf_priorProbs = [.5, .5, .5]
var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
inf_priorProbs, speakerOptimality)
observe(rsaPredictions, row.correct)
}, infData)
var pref_params = map(function(cndtn){
var conditionData = filter(prefData, {condition: cndtn})
var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})
map(function(row){
var age = row.age_num
var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
var priorProbs= [1-priorReg, priorReg]
var priorPredictions = Infer({method: "enumerate", model: function(){
var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
return obj.shape == "circle" ? 1 : 0
}})
observe(priorPredictions, row.correct)
// display(JSON.stringify(priorReg))
}, conditionData)
return {pref_int, pref_slope, condition: cndtn}
}, all_conditions)
var diff_speaker_params = filter(pref_params,
{condition: "different_speaker"})[0]
var same_speaker_params = filter(pref_params,
{condition: "same_speaker"})[0]
var predictions_by_age = map(function(age_bin){
var speakerOptimality = so_int  + so_slope * age_bin
var diff_priorReg = logistic(diff_speaker_params.pref_int +
diff_speaker_params.pref_slope * age_bin)
var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]
var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent, speakerOptimality))
var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
var same_priorReg = logistic(same_speaker_params.pref_int +
same_speaker_params.pref_slope * age_bin)
var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]
var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]
var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))
var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))
return extend(
//diff_speaker_params, same_speaker_params,
{
// diff_priorReg,
//  same_priorReg,
//  speakerOptimality,
rsaPredictions_diff_cong,
rsaPredictions_diff_incong,
rsaPredictions_same_cong,
rsaPredictions_same_incong,
age_bin,
//  so_slope,
//  so_int
})
}, binned_age_range)
return predictions_by_age
}
'
model_pred<- webppl(
program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
data = pre_data,
data_var = "dataFromR",
model_var = "model",
chains = 1,
cores = 1,
inference_opts = list(method = "MCMC", samples = 20, burn = 1, verbose = T)
)
