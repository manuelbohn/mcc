---
title: "MCC Kids Model Predictions"
author: "Manuel Bohn"
output: 
  html_document:
      code_folding: hide
---

```{r, include = F}
knitr::opts_chunk$set(echo = TRUE, warning = F)
```


```{r setup, include=FALSE}
library(tidyverse)
library(knitr)
library(ggthemes)
library(ggpubr)
library(langcog)
library(rwebppl)
library(coda)
library(reshape2)

estimate_mode <- function(s) {
  d <- density(s)
  return(d$x[which.max(d$y)])
}

hdi_upper<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","upper"])
}

hdi_lower<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","lower"])
}

```

# Pretest

```{r pretest data, include=FALSE}

pref_data <- bind_rows(read_csv(file="../data/kids_pref_data.csv")%>%filter(age != "2")%>%mutate(speakerChange = change),
                       read_csv(file="../data/kids_pref_2_data.csv"))%>%
  filter(trial != "train")%>%
  mutate(age_bin = factor(age),
         experiment = "preference_pretest",
         condition = ifelse(speakerChange == F | speakerChange == "false", "same_speaker", "different_speaker"),
         agent = ifelse( speakerChange == F | speakerChange == "false", agent, altAgent),
         minage = min(age_num))%>%
  select(experiment,subid,age_bin,age_num,trial,condition,agent,correct,minage)


inf_data <- bind_rows(
  read_csv(file="../data/kids_inf_data.csv"),
  read_csv(file="../data/kids_inf_2_data.csv"))%>%
  filter(subage != "2",
         trial != "filler1",
         trial != "filler2")%>%
  mutate(age_bin = factor(subage),
         experiment = "informativeness_pretest",
         condition = ifelse(control == "no", "test", "control"),
        minage = min(age_num))%>%
  select(experiment,subid,age_bin,age_num,trial,condition,agent,correct,minage)
  
pre_data <- bind_rows(pref_data,
                      inf_data)


ex3_data <- read_csv(file="../data/kids_ex3_data.csv")%>%
  filter(trial != "filler1",trial != "filler2")

```

## Pretest results

This is the data we use to estimate the speaker optimality nad the age specific prior.

```{r pretest plot so, echo = F}

pre_so <- pre_data %>%
  filter(experiment == "informativeness_pretest")%>%
  group_by(age_num,subid)%>%
  summarise(correct = mean(correct))


plot_inf <- ggplot(data = pre_so, aes(x = age_num, y = correct)) +
  geom_jitter(alpha = 1, height = 0.1, width = 0.1, col = "grey")+
  geom_smooth(method = "lm", se = T, col = "black",fill = "darkgreen", alpha = .4, size = .4)+
  geom_hline(yintercept = 0.5, lty=2)+
  labs(x="age",y="Proportion Expected Choice")+
  theme_few() +
  ggtitle("Informativeness data")+
  ylim(-0.05,1.05)+
  guides(alpha = F)+ 
  coord_fixed(ratio = 2)
```

```{r pretest plot prior, echo = F}

pre_prior <- pre_data %>%
  filter(experiment == "preference_pretest")%>%
  group_by(condition,age_num,subid)%>%
  summarise(correct = mean(correct))


plot_pref <- ggplot(data = pre_prior, aes(x = age_num, y = correct, col = condition)) +
  geom_jitter(alpha = 0.5, height = 0.1, width = 0.1)+
  geom_smooth(aes(fill = condition),method = "lm", se = T, col = "black",  alpha = .5, size = .4)+
  geom_hline(yintercept = 0.5, lty=2)+
  labs(x="",y="Proportion Preferred Choice")+
  theme_few() +
  #ggtitle("Preference data")+
  ylim(-0.05,1.05)+
  guides(alpha = F)+ 
  coord_fixed(ratio = 2)+
  scale_color_solarized()+
  scale_fill_solarized()



```


```{r}

ggsave("../graphs/ex_2_kids_pref.png", width = 2, height = 2, scale = 2)

```


```{r, echo = F, fig.width= 8}
ggarrange(plot_inf, plot_pref, widths = c(1.29,2))
```







## RSA model

### Model utensils. 

There are two types of objects, one used in the 3-object world of the RSA model (`all_objects`) and one used in the 2-object world of the prior (`prior_objects`). 

```{r rsaUtils}
rsaUtils <- '
var all_objects = [
{ shape: "triangle", id:1, location: 1},  
{ shape: "triangle", id:2, location: 2},
{ shape: "circle", id:1, location: 2}
]

var prior_objects = [
{ shape: "triangle", id:1, location: 1},  
{ shape: "circle", id:1, location: 2}
]

var labels = ["dax","wug"]

var lexicon1 = function(utterance, obj){
utterance.label == "dax" ? obj.shape == "triangle" :
utterance.label == "wug" ? obj.shape == "circle" : 
true
}

var lexicon2 = function(utterance, obj){
utterance.label == "dax" ? obj.shape == "circle" :
utterance.label == "wug" ? obj.shape == "triangle" : 
true
}

var lexiconObjects = {
"dax = triangle": {
triangle: "dax", circle: "wug"
},
"dax = circle": {
triangle: "wug", circle: "dax"
},
}

var lexiconObject = {
"dax = triangle": lexicon1,
"dax = circle" : lexicon2
}

var point = function(utterance, obj){
return obj.location == utterance.point
}


var utterancePrior = function(obj, lexiconName){
var locationsWithShape = _.map(_.filter(all_objects, {shape: obj.shape}), "location")
var point = uniformDraw(locationsWithShape)
var label = lexiconObjects[lexiconName][obj.shape]
return {label: label, point: point}
}

var LexiconPrior = Categorical({vs: ["dax = triangle","dax = circle" ], ps: [1, 1]})

var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var logistic = function(x) {1 / (1 + Math.exp(-x))}

'
```

### RSA model code 

```{r rsa model}

rsaModel <- '
var literalListener = cache(function(utterance, priorProbs){
Infer({method: "enumerate", model: function(){
var lexiconName = sample(LexiconPrior); 
var lexicon = lexiconObject[lexiconName];
var obj = sample( Categorical({vs: all_objects, ps: priorProbs}));
if ("label" in utterance) {
 var truthValue = lexicon(utterance, obj);
 condition(truthValue)
}
if (utterance.point) {
 var truthValuePoint = point(utterance, obj);
 condition(truthValuePoint)
}
return obj.shape 
}})
})

var speaker = cache(function(obj, lexiconName, priorProbs, speakerOptimality){
Infer({method: "enumerate", model: function(){
var utterance = utterancePrior(obj, lexiconName);
var L0 = literalListener(utterance, priorProbs);
 factor(speakerOptimality * L0.score(obj.shape))
return utterance
}})
})

var pragmaticListener = cache(function(utterance, priorProbs, speakerOptimality){
Infer({method: "enumerate", model: function(){
var lexiconName = sample(LexiconPrior);
var obj = sample( Categorical({vs: all_objects, ps: priorProbs}));
var S1 = speaker(obj, lexiconName, priorProbs, speakerOptimality);
observe(S1, utterance)
return obj.shape == "circle" ? 1 : 0
}})
})


var addNoise = function(dist, noiseParam){
   Infer({model: function(){ 
      return flip(noiseParam) ? uniformDraw([0, 1]) : sample(dist)
    }
   })
}
'
```


### Priors for intercept and slope for speaker optimality and preference

Sanity check for the priors on slope and intercept.

#### Speaker optimality

```{r prior speaker optimality slope}
priorSoWebppl <- '
var infData = dataFromR
var priorProbs = [.5, .5, .5] 
var speakerOptimality = []
var model  = function(){
  var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
  var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
    map(function(row){
      var age = row.age_num
      var speakerOptimality = so_int  + so_slope * (age - row.minage)
      var rsaPredictions = pragmaticListener({label: "dax", point: 2 }, priorProbs, speakerOptimality) 
      
      //display(JSON.stringify(row.minage))
    }, infData)
  return extend({so_int: so_int, so_slope: so_slope})
}
'
```

```{r speaker optimality prior pred}
so_prior <- readRDS("../saves/so_prior.rds")
# so_prior<- webppl(
#   program_code = paste(rsaUtils, rsaModel, priorSoWebppl , sep='\n'),
#   data = inf_data%>%mutate(minage = min(age_num)), 
#   data_var = "dataFromR",
#   model_var = "model",
#   chains = 1,
#   inference_opts = list(method = "forward", samples = 1000, verbose = T)
# )
#saveRDS(so_prior, "../saves/so_prior.rds")

priorPred <- so_prior%>%
  spread(Parameter, value)%>%
  mutate(chain = factor(Chain))

so_prior <- so_prior%>%
  mutate(chain = factor(Chain))

mean_so_pre <-priorPred%>%
  summarise(int = mean(so_int),
            slope = mean(so_slope))


so_prior_plot <- ggplot(data = priorPred) +
  geom_abline(aes(intercept = so_int, slope = so_slope), col = "grey", alpha = 0.3)+
  geom_abline(data = mean_so_pre, aes(intercept = int, slope = slope), size = 0.4)+
  scale_x_continuous(limits=c(0, 2), name="age", breaks = c(0:2), labels = c(3:5)) +
  scale_y_continuous(limits=c(-4, 4), name="Speaker optimality")+
  ggtitle("Model speaker optimality prior")+
  coord_fixed(ratio=1/4)+
  theme_few()
```

#### Preference

```{r prior preference congruent}
priorPreWebppl <- '
var prefData = dataFromR
var priorProbs = [] 
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
  var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
  var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})
    map(function(row){
      var age = row.age_num
      var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
      var priorProbs= [1-priorReg, priorReg]
      var priorPredictions = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
      return obj.shape == "circle" ? 1 : 0
      }})
      
      // observe(priorPredictions, row.correct)
     // display(JSON.stringify(priorReg))
    }, prefData)
  return extend({pref_int: pref_int, pref_slope: pref_slope})
}
'
```

```{r}
pref_prior_con <- readRDS("../saves/pref_prior_con.rds")

# pref_prior_con<- webppl(
#   program_code = paste(rsaUtils, rsaModel, priorPrefConWebppl , sep='\n'),
#   data = pref_data%>%mutate(minage = min(age_num)), 
#   data_var = "dataFromR",
#   model_var = "model",
#   chains = 1,
#   inference_opts = list(method = "forward", samples = 1000, verbose = T)
# )
 # saveRDS(pref_prior_con, "../saves/pref_prior_con.rds")

prefPriorPredCon <- pref_prior_con%>%
  spread(Parameter, value)

pref_prior_con <- pref_prior_con%>%
  mutate(chain = factor(Chain),
         Alignment = "congruent")

x_plot <- seq(0, 2, by = 0.1)
model_predictions <- sapply(1:length(prefPriorPredCon$pref_int), function(idx) {
            plogis(prefPriorPredCon$pref_int[idx] + prefPriorPredCon$pref_slope[idx] * x_plot)
        })
colnames(model_predictions) <- 1:length(prefPriorPredCon$pref_int)
plot_pref_prior_con <- as.data.frame(cbind(x_plot, model_predictions))
plot_pref_prior_con <- melt(plot_pref_prior_con, id.vars = "x_plot", variable.name = "iteration", 
        value.name = "y_plot")

plot_prior_con_mean <- plot_pref_prior_con%>%
  group_by(x_plot)%>%
  summarise(y_plot = mean(y_plot))


pref_prior_plot <- ggplot(plot_pref_prior_con) + 
  geom_line(aes(x_plot, y_plot, group = iteration), col = "grey",alpha = 0.2) +
  #geom_ribbon(data = plot_prior_mean, aes(x =x_plot, ymin = ci_lower, ymax = ci_upper), fill = "red", alpha = 0.5) +
  geom_line(data = plot_prior_con_mean, aes(x_plot, y_plot), col = "black", size = 0.4) +
  xlab("age") + ylab("Proportion Expected Choice") +
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0:2), labels = c(3:5)) +
  scale_y_continuous(limits = c(0, 1), name="P in favor of preferred object")+
  ggtitle("Model preference prior")+
  coord_fixed(ratio=2)+
  theme_few()
```

```{r, echo = F, fig.width= 8}
ggarrange(so_prior_plot, pref_prior_plot)
```

There is no information in the priors. All structure in the models further down comes from the data

# Model Predictions Across age bins

## RSA model predictions across age bins

```{r}
modelPredAcrossWebppl <- '
var levels = function(df, label){
  return _.uniq(_.map(df, label));
}
var prefData = _.filter(dataFromR, {experiment: "preference_pretest"})
var infData = _.filter(dataFromR, {experiment: "informativeness_pretest"})
// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.05)
var all_conditions = levels(prefData, "condition")
var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};
var logistic = function(x) {1 / (1 + Math.exp(-x))}
var model  = function(){
  var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
  var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
  foreach(function(row){
    var age = row.age_num
    var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
    
    var inf_priorProbs = [.5, .5, .5] 
    var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
    inf_priorProbs, speakerOptimality) 
    
    observe(rsaPredictions, row.correct)
  }, infData)
  var pref_params = map(function(cndtn){
    var conditionData = _.filter(prefData, {condition: cndtn})
    
    var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
    var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})    
    
    foreach(function(row){
      var age = row.age_num
      var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
      var priorProbs= [1-priorReg, priorReg]
      var priorPredictions = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
      return obj.shape == "circle" ? 1 : 0
      }})
      
      observe(priorPredictions, row.correct)
    }, conditionData)
    
    return {pref_int, pref_slope, condition: cndtn}
    
  }, all_conditions)
  
  var diff_speaker_params = _.filter(pref_params, 
        {condition: "different_speaker"})[0]
  var same_speaker_params = _.filter(pref_params, 
        {condition: "same_speaker"})[0]
        
  var predictions_by_age = map(function(age_bin){
    
    var speakerOptimality = so_int  + so_slope * age_bin
    
    var diff_priorReg = logistic(diff_speaker_params.pref_int +
            diff_speaker_params.pref_slope * age_bin)
    var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]
    var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
      
    var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent,   speakerOptimality))
    var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
      
    var same_priorReg = logistic(same_speaker_params.pref_int +
            same_speaker_params.pref_slope * age_bin)
    var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]
    var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]
    var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))
    var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))
    return extend(
    // diff_speaker_params, same_speaker_params, 
      {
     diff_priorReg,
     same_priorReg,
     speakerOptimality,
    rsaPredictions_diff_cong,
    rsaPredictions_diff_incong,
    rsaPredictions_same_cong,
      rsaPredictions_same_incong,
      age_bin,
    //  so_slope,
    //  so_int,
    })
    
  }, binned_age_range)
  
  return predictions_by_age
}
'
```

Taking samples and munging the data. 

```{r combined model predictions}
model_pred_across <- readRDS("../saves/kids_model_predictions_across.rds")

model_pred_across<- webppl(
  program_code = paste(rsaUtils, rsaModel, modelPredAcrossWebppl , sep='\n'),
  data = pre_data,
  data_var = "dataFromR",
  model_var = "model",
  chains = 4,
  cores = 4,
  inference_opts = list(method = "MCMC", samples = 900, burn = 200, verbose = T)
)

saveRDS(model_pred, file = "../saves/kids_model_predictions.rds")

kids_model_pred_across <- model_pred_across%>%
  select(value) %>%
  map_df(bind_rows)%>%
  mutate(iteration = rep(1:3400,each = 40))%>%
  select(-diff_priorReg,-same_priorReg,-speakerOptimality,-so_slope,-so_int)%>%
  gather(condition, prop_informative, -iteration,-age_bin)%>%
  separate(condition, into = c("model", "Speaker", "Alignment"), sep="_")%>%
  mutate(Speaker = ifelse(Speaker == "diff", "different_speaker","same_speaker"),
         Alignment = ifelse(Alignment == "cong", "congruent","incongruent"))

kids_model_pred_so <- model_pred_across%>%
  select(value) %>%
  map_df(bind_rows)%>%
  mutate(iteration = rep(1:3400,each = 40))%>%
  select(so_slope,so_int,age_bin,iteration,speakerOptimality)

kids_model_pred_prior <- model_pred_across%>%
  select(value) %>%
  map_df(bind_rows)%>%
  mutate(iteration = rep(1:3400,each = 40))%>%
  select(age_bin,iteration,diff_priorReg,same_priorReg)%>%
  gather(condition, prop_preferred, -iteration,-age_bin)%>%
  mutate(condition = ifelse(condition == "diff_priorReg", "different_speaker","same_speaker"))

```

## Prior only model 

```{r prior only model}
priorOnlyWebppl <- '

var levels = function(df, label){
  return _.uniq(_.map(df, label));
}
var prefData = _.filter(dataFromR, {experiment: "preference_pretest"})

// make finer grained as needed
var binned_age_range = _.range(0, 2, 0.05)

var all_conditions = levels(prefData, "condition")

var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var logistic = function(x) {1 / (1 + Math.exp(-x))}

var model  = function(){

  var pref_params = map(function(cndtn){

    var conditionData = _.filter(prefData, {condition: cndtn})
    
    var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
    var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})    
    
    foreach(function(row){

      var age = row.age_num

      var priorReg = logistic(pref_int + pref_slope * (age - row.minage))

      var priorProbs= [1-priorReg, priorReg]

      var priorPredictions = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
      return obj.shape == "circle" ? 1 : 0
      }})
      
      observe(priorPredictions, row.correct)

    }, conditionData)
    
    return {pref_int, pref_slope, condition: cndtn}
    
  }, all_conditions)
  
  var diff_speaker_params = _.filter(pref_params, 
        {condition: "different_speaker"})[0]

  var same_speaker_params = _.filter(pref_params, 
        {condition: "same_speaker"})[0]
        
  var predictions_by_age = map(function(age_bin){
    
    
    var diff_priorReg = logistic(diff_speaker_params.pref_int +
            diff_speaker_params.pref_slope * age_bin)

    var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]

    var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
      

    var same_priorReg = logistic(same_speaker_params.pref_int +
            same_speaker_params.pref_slope * age_bin)

    var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]

    var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]


 var priorPredictions_diff_con = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: all_objects, ps: diff_priorProbs_congruent}));
      return obj.shape == "circle" ? 1 : 0
      }})

  var priorPredictions_diff_incon = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: all_objects, ps: diff_priorProbs_incongruent}));
      return obj.shape == "circle" ? 1 : 0
      }})

 var priorPredictions_same_con = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: all_objects, ps: same_priorProbs_congruent}));
      return obj.shape == "circle" ? 1 : 0
      }})

  var priorPredictions_same_incon = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: all_objects, ps: same_priorProbs_incongruent}));
      return obj.shape == "circle" ? 1 : 0
      }})



     var prior_diff_con = Math.exp(priorPredictions_diff_con.score(1))
var prior_diff_incon = Math.exp(priorPredictions_diff_incon.score(1))
     var prior_same_con = Math.exp(priorPredictions_same_con.score(1))
var prior_same_incon = Math.exp(priorPredictions_same_incon.score(1))


    return extend(
      {prior_diff_con,
prior_diff_incon,
prior_same_con,
prior_same_incon,
    age_bin})


    
  }, binned_age_range)
  
  return predictions_by_age 
}
'
```

```{r}

prior_only_predictions_across <- readRDS("../saves/prior_only_predictions_across.rds")

# prior_only_predictions<- webppl(
#   program_code = paste(rsaUtils, rsaModel, priorOnlyWebppl , sep='\n'),
#   data = pre_data,
#   data_var = "dataFromR",
#   model_var = "model",
#   chains = 3,
#   cores = 3,
#   inference_opts = list(method = "MCMC", samples = 1000, burn = 200, verbose = T)
# )

#saveRDS(prior_only_predictions, "../saves/prior_only_predictions.rds")


prior_only_model_across <- prior_only_predictions_across %>%
  select(value) %>%
  map_df(bind_rows)%>%
  mutate(iteration = rep(1:4000,each = 40))%>%
  gather(condition, prop_informative, -iteration,-age_bin)%>%
  separate(condition, into = c("model", "Speaker", "Alignment"), sep="_")%>%
  mutate(Speaker = ifelse(Speaker == "diff", "different_speaker","same_speaker"),
         Alignment = ifelse(Alignment == "con", "congruent","incongruent"))


```


## Sanity checks

### Model based speaker optimality by age 

```{r plot so model pred, echo = F}

plot_model_pred_so <- kids_model_pred_so%>%
  group_by(age_bin)%>%
  summarise(mean = mean(speakerOptimality),
            lci = hdi_lower(speakerOptimality),
            uci = hdi_upper(speakerOptimality))
  

pred_so_plot <- ggplot(data = plot_model_pred_so) +
  geom_line(data = kids_model_pred_so,aes(age_bin, speakerOptimality, group = iteration), col = "grey", alpha = 0.3) +
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci), fill = "green", alpha = .2) +
  geom_line(aes(age_bin, mean), col = "black", size = 0.4, alpha = 1) + 
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  scale_y_continuous(limits=c(-4, 4), name="Speaker optimality")+
  ggtitle("Speaker optimality model")+
  #facet_wrap(~chain)+
  theme_few()+
  coord_fixed(ratio=1/4)

```


```{r, echo = F, fig.width= 8}
ggarrange(pred_so_plot, plot_inf)
```

Here we estimate the speaker optimality parameter that best captures the data for the different ages. The model based estimate nicely captures the developmental trend.

```{r plot prior model pred, echo = F}
plot_model_pred_prior <- kids_model_pred_prior%>%
  group_by(age_bin,condition)%>%
  summarise(mean = mean(prop_preferred),
            lci = hdi_lower(prop_preferred),
            uci = hdi_upper(prop_preferred))
  

pred_prior_plot <- ggplot(data = plot_model_pred_prior) +
  geom_line(data = kids_model_pred_prior,aes(age_bin, prop_preferred, group = paste(iteration,condition, sep= ""), col = condition), alpha = 0.05) +
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci, fill = condition), alpha = .5) +
  geom_line(aes(age_bin, mean, group = condition), col = "black", size = 0.4, alpha = 1) + 
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  scale_y_continuous(limits=c(-0.05,1.05), name="Proportion Expected Choice")+
  geom_hline(yintercept = 0.5, lty=2)+
  theme_few()+
  ggtitle("Preference model")+
  coord_fixed(ratio = 2)+
  scale_color_solarized()+
  scale_fill_solarized()


```

### Model based priors by age 

```{r, echo= F, fig.width= 10}
ggarrange(pred_prior_plot, plot_pref, common.legend = T, legend = "right")
```

The model accurately captures the the difference between conditions as well as the developmental trend we see in the data.  

## Visualizing model predictions

### RSA Model Predictions

These are the predictions from the RSA model which takes in the age specific speaker optimality parameter and the age specific priors. The priors are converted from 2-object world into 3-object world before going into the model. This corresponds to the way we handled the priors for adults.

```{r plot RSA model predictions, echo = F}

  model_pred_across <- kids_model_pred_across %>%
  group_by(model,age_bin,Speaker,Alignment)%>%
  summarise(mean = mean(prop_informative),
            lci = hdi_lower(prop_informative),
            uci = hdi_upper(prop_informative))

ggplot(model_pred_across)+
  #geom_pointrange(aes(y = mean, ymin = lci, ymax = uci))+
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci), alpha = .4) +
  geom_line(aes(age_bin, mean), col = "black", size = 0.4, alpha = 1) + 
  geom_hline(yintercept = 0.5, lty=2)+
  labs(y="Proportion Expected Choice")+
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  ylim(-0.05,1.05)+
  guides(col = F)+
  facet_grid(Speaker~Alignment)+
  theme_few()+
  scale_color_solarized()+
  scale_fill_solarized()
```

## No Prior Model Predictions Across

```{r, include = F}

no_prior_pred_across <- bind_rows(
  kids_model_pred_so%>%mutate(model = "no prior",
                              Speaker = "same_speaker",
                              Alignment = "congruent"),
    kids_model_pred_so%>%mutate(model = "no prior",
                              Speaker = "different_speaker",
                              Alignment = "congruent"),
    kids_model_pred_so%>%mutate(model = "no prior",
                              Speaker = "same_speaker",
                              Alignment = "incongruent"),
    kids_model_pred_so%>%mutate(model = "no prior",
                              Speaker = "different_speaker",
                              Alignment = "incongruent")
  ) %>%
  mutate(prop_informative = plogis(so_int+so_slope*age_bin))


no_prior_plot <- no_prior_pred %>%
  group_by(model,age_bin,Speaker,Alignment)%>%
  summarise(mean = mean(prop_informative),
            lci = hdi_lower(prop_informative),
            uci = hdi_upper(prop_informative))

plot_no_prior <- ggplot(no_prior_plot)+
  geom_line(data = no_prior_pred,aes(age_bin, prop_informative, group = paste(iteration,Speaker, sep= ""), col = Speaker),  alpha = 0.05) + 
  #geom_pointrange(aes(y = mean, ymin = lci, ymax = uci))+
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci, fill = Speaker), alpha = .4) +
  geom_line(aes(age_bin, mean), col = "black", size = 0.4, alpha = 1) + 
  geom_hline(yintercept = 0.5, lty=2)+
  labs(y="Proportion Expected Choice")+
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  ylim(-0.05,1.05)+
  guides(col = F)+
  facet_grid(Speaker~Alignment)+
  theme_few()+
  scale_color_solarized()+
  scale_fill_solarized()
```

```{r, echo = F, fig.width= 10, fig.height = 8}
plot_no_prior
```

## Prior Only Model

```{r plot prior only model predictions, include= F}

plot_prior_only_pred <- prior_only_model %>%
  group_by(model,age_bin,Speaker,Alignment)%>%
  summarise(mean = mean(prop_informative),
            lci = hdi_lower(prop_informative),
            uci = hdi_upper(prop_informative))

prior_only_plot <- ggplot(plot_prior_only_pred)+
  geom_line(data = prior_only_model,aes(age_bin, prop_informative, group = paste(iteration,Speaker, sep= ""), col = Speaker),  alpha = 0.05) + 
  #geom_pointrange(aes(y = mean, ymin = lci, ymax = uci))+
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci, fill = Speaker), alpha = .4) +
  geom_line(aes(age_bin, mean), col = "black", size = 0.4, alpha = 1) + 
  geom_hline(yintercept = 0.5, lty=2)+
  labs(y="Proportion Expected Choice")+
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  ylim(-0.05,1.05)+
  facet_grid(Speaker~Alignment)+
  theme_few()+
  scale_color_solarized()+
  scale_fill_solarized()

```

```{r, echo = F, fig.width= 10, fig.height = 8}
prior_only_plot
```


## Comparing model predictions

```{r}
model_comp_mean_ci <- bind_rows(
kids_model_pred_across%>%mutate(model = "RSA"), 
prior_only_model_across%>%mutate(model = "Prior Only"),
no_prior_pred_across%>%mutate(model = "No Prior")
)%>%
  group_by(model,age_bin,Speaker,Alignment)%>%
  summarise(mean = mean(prop_informative),
            lci = hdi_lower(prop_informative),
            uci = hdi_upper(prop_informative))

#saveRDS(model_comp_mean_ci, "../saves/kids_model_comp_mean_ci.rds")

```


```{r, include = F}
pred_plot <- ggplot(model_comp_mean_ci)+
  geom_line(data = model_comp,aes(age_bin, prop_informative, group = paste(iteration,Speaker,model, sep= ""), col = model),  alpha = 0.01) + 
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci, fill = model), alpha = .4) +
  geom_line(aes(age_bin, mean, col = model), size = 1, alpha = 1) + 
  geom_hline(yintercept = 0.5, lty=2)+
  labs(y="proportion more informative")+
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  ylim(-0.05,1.05)+
  facet_grid(Speaker~Alignment)+
  theme_few()+
  scale_color_viridis_d()+
  scale_fill_viridis_d()
```

```{r, echo = F, fig.width= 10, fig.height = 8}
pred_plot
```

```{r, include = F}
#ggsave("../graphs/no_prior_prior_only_model_predictions.pdf", width = 10, height = 8, scale = 1)
```

## Model vs data

### Predictions across age bins

```{r comparison plot, echo= FALSE}
p_data <- ex3_data %>%
  filter(trial != "filler1",
         trial != "filler2")%>%
  mutate(age_bin = age_num - 3)%>%
  group_by(Speaker, Alignment ,age_bin, subid)

ggplot(model_comp_mean_ci)+
  #geom_jitter(data = p_data, aes(x = age_bin, y = correct_inf), width = .025,height = .025, alpha = .2)+
  geom_ribbon(aes(x =age_bin, ymin = lci, ymax = uci, fill = model), alpha = .4) +
  geom_line(aes(age_bin, mean, col = model), size = .7, alpha = 1, linetype = 1) + 
  geom_smooth(data = p_data, aes(x = age_bin, y = correct_inf), col = "black", size = 0.6, method = "glm", method.args = list(family = "binomial"),  se = T,  alpha = .5, size = .4)+
  geom_hline(yintercept = 0.5, lty=2)+
  labs(y="proportion more informative")+
  scale_x_continuous(limits=c(0,2), name="age", breaks = c(0,0.5,1,1.5,2), labels = c(3.0,3.5,4.0,4.5,5)) +
  ylim(-0.05,1.05)+
  facet_grid(Speaker~Alignment)+
  theme_few()+
  scale_color_solarized()+
  scale_fill_solarized()

```



### Correlation plot
```{r}

data <- ex3_data %>%
  filter(trial != "filler1",
         trial != "filler2")%>%
  group_by(Speaker, Alignment ,subage) %>%
  summarize(k = sum(correct_inf), n = n())%>%
  ungroup() %>%
  mutate(a = 1 + k,
         b = 1 + n - k,
         Data_ci_lower  = qbeta(.025, a, b),
         Data_ci_upper = qbeta(.975, a, b),
         Data = (a-1)/(a+b-2))%>%
  select(-a,-b,-n,-k)

model <- kids_model_pred_across %>%
  mutate(subage = ifelse(age_bin<1,"3","4"))%>%
  group_by(model,Speaker,Alignment,subage)%>%
  summarise(Model = mean(prop_informative),
            Model_ci_lower =hdi_lower(prop_informative) ,
            Model_ci_upper = hdi_upper(prop_informative))
  

cor_plot <- model %>%
  ungroup()%>%
  mutate(Data = data$Data,
         Data_ci_lower = data$Data_ci_lower,
         Data_ci_upper  =data$Data_ci_upper,3)


ggplot(data = cor_plot,aes(x = Model, y = Data, col = subage)) +
  geom_abline(intercept = 0, slope = 1, lty = 2, alpha = 1, size = .5)+
  geom_point(size = 3)+
  geom_errorbar(aes(ymin = Data_ci_lower, ymax = Data_ci_upper),width = 0,size = .5)+
  geom_errorbarh(aes(xmin = Model_ci_lower, xmax = Model_ci_upper), height = 0,size = .5)+
  coord_fixed()+
  stat_cor(method = "pearson", label.x = 0.1, label.y = 0.9, aes(x = Model, y = Data), inherit.aes = F)+
  facet_grid(~model)+
  xlim(0,1)+ylim(0,1)+
  xlab("Model")+
  theme_few(base_size = 10) + 
  scale_colour_solarized()


cor.test(cor_plot$Model,cor_plot$Data)
```

# Model predictions by age bin

## Model parameters by age bin

```{r}
paramModelWebppl <- '

var levels = function(df, label){
  return _.uniq(_.map(df, label));
}
var prefData = _.filter(dataFromR, {experiment: "preference_pretest"})
var infData = _.filter(dataFromR, {experiment: "informativeness_pretest"})

// make finer grained as needed

var binned_age_range = _.range(0, 2, 0.05)
var all_conditions = levels(prefData, "condition")
var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var logistic = function(x) {1 / (1 + Math.exp(-x))}

var model  = function(){
  var so_slope = uniformDrift({a: -2, b: 2, width: 0.4})
  var so_int = uniformDrift({a: -2, b: 2, width: 0.4})
  foreach(function(row){
    var age = row.age_num
    var speakerOptimality = so_int  + so_slope * (age - infData[0].minage)
    
    var inf_priorProbs = [.5, .5, .5] 
    var rsaPredictions = pragmaticListener({label: "dax", point: 2 },
    inf_priorProbs, speakerOptimality) 
    
    observe(rsaPredictions, row.correct)
  }, infData)

  var pref_params = map(function(cndtn){
    var conditionData = _.filter(prefData, {condition: cndtn})
    
    var pref_slope = uniformDrift({a: -2, b: 2, width: 0.4})
    var pref_int = uniformDrift({a: -2, b: 2, width: 0.4})    
    
    foreach(function(row){
      var age = row.age_num
      var priorReg = logistic(pref_int + pref_slope * (age - row.minage))
      var priorProbs= [1-priorReg, priorReg]

      var priorPredictions = Infer({method: "enumerate", model: function(){
      var obj = sample( Categorical({vs: prior_objects, ps: priorProbs}));
      return obj.shape == "circle" ? 1 : 0
      }})
      
      observe(priorPredictions, row.correct)
    }, conditionData)
    
    return [
      {condition: cndtn, param: "pref_int", val: pref_int}, 
      {condition: cndtn, param: "pref_slope", val: pref_slope}
    ]
    
  }, all_conditions)
  
        
  return _.flatten(pref_params).concat(
    [
      {condition: "NA", param: "so_slope", val: so_slope},
      {condition: "NA", param: "so_int", val: so_int}
    ]
  )
}
'
```

```{r}
params_by_age<- readRDS("../saves/params_by_age.rds")

params_by_age<- webppl(
  program_code = paste(rsaUtils, rsaModel, paramModelWebppl , sep='\n'),
  data = pre_data,
  data_var = "dataFromR",
  model_var = "model",
  chains = 4,
  cores = 4,
  inference_opts = list(method = "MCMC", samples = 2000, burn = 200, verbose = T)
)

#saveRDS(params_by_age, file = "../saves/params_by_age.rds")

model_params <- params_by_age%>%
  select(value) %>%
  map_df(bind_rows)%>%
  group_by(condition,param)%>%
  summarise(param_map = estimate_mode(val))%>%
  mutate(cond = paste(condition, param, sep = "_"))%>%
  ungroup()%>%
  select(cond,param_map)%>%
  spread(cond,param_map)




```

## RSA model predictions by age bin 

```{r}
modelPredWebppl <- '

var levels = function(df, label){
  return _.uniq(_.map(df, label));
}

var age_bins = _.range(0, 2, 0.05)
var ex3Data = dataFromR.ex3data
var modelParams = dataFromR.modelParams[0]


   //display(JSON.stringify(modelParams))

var predict_by_age = function(age_bin){

    //display(JSON.stringify(age_bin))

    var speakerOptimality = modelParams.NA_so_int + modelParams.NA_so_slope * age_bin

    var diff_priorReg = logistic(modelParams.different_speaker_pref_int + modelParams.different_speaker_pref_slope * age_bin)

    //display(JSON.stringify(modelParams))

    var diff_priorProbs_congruent = [1-diff_priorReg, 1-diff_priorReg, diff_priorReg]

    var diff_priorProbs_incongruent = [diff_priorReg, diff_priorReg, 1-diff_priorReg]
      
    var rsaPredictions_diff_cong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_congruent,   speakerOptimality))

    var rsaPredictions_diff_incong = expectation(pragmaticListener({label: "dax", point: 2 }, diff_priorProbs_incongruent, speakerOptimality))
      
    var same_priorReg = logistic(modelParams.same_speaker_pref_int + modelParams.same_speaker_pref_slope * age_bin)

    var same_priorProbs_congruent = [1-same_priorReg, 1-same_priorReg, same_priorReg]

    var same_priorProbs_incongruent = [same_priorReg, same_priorReg, 1-same_priorReg]

    var rsaPredictions_same_cong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_congruent, speakerOptimality))

    var rsaPredictions_same_incong = expectation(pragmaticListener({label: "dax", point: 2 }, same_priorProbs_incongruent, speakerOptimality))

  return extend(
      {rsaPredictions_diff_cong,
      rsaPredictions_diff_incong,
      rsaPredictions_same_cong,
      rsaPredictions_same_incong,
      age_bin
    })

 }

var predictions_by_age = map(predict_by_age, age_bins)

predictions_by_age

'
```


```{r combined model predictions}

model_pred<- webppl(
  program_code = paste(rsaUtils, rsaModel, modelPredWebppl , sep='\n'),
  data = list(ex3data = ex3_data_param, modelParams = model_params),
  data_var = "dataFromR"
)

#saveRDS(model_pred, file = "../saves/kids_model_predictions.rds")

pred <- model_pred %>%
  gather(condition, mean, -age_bin)%>%
  separate(condition, into = c("model", "Speaker", "Alignment"), sep="_")%>%
  mutate(Speaker = ifelse(Speaker == "diff", "different_speaker","same_speaker"),
         Alignment = ifelse(Alignment == "cong", "congruent","incongruent"),
         model = "parameter free", 
         age = age_bin+3)%>%
  select(-age_bin)
```

## Noisy RSA model Predictions 

```{r}

ex3_data_param <- ex3_data%>%
  mutate(different_speaker_pref_int = model_params$different_speaker_pref_int,
         different_speaker_pref_slope = model_params$different_speaker_pref_slope,
         so_int = model_params$NA_so_int,
         so_slope = model_params$NA_so_slope,
         same_speaker_pref_int = model_params$same_speaker_pref_int,
         same_speaker_pref_slope = model_params$same_speaker_pref_slope,
         so = plogis(so_int+so_slope*(age_num-min(age_num))),
         diff_prior = plogis(different_speaker_pref_int+different_speaker_pref_slope*(age_num-min(age_num))),
         same_prior = plogis(same_speaker_pref_int+same_speaker_pref_slope*(age_num-min(age_num))))%>%
  group_by(subid,trial)%>%
        mutate(priorProbs = ifelse(Speaker == "same_speaker" & Alignment == "congruent", list(c(1-same_prior,1-same_prior,same_prior)),
                                   ifelse(Speaker == "different_speaker" & Alignment == "congruent", list(c(1-diff_prior,1-diff_prior,diff_prior)),
                                          ifelse(Speaker == "same_speaker" & Alignment == "incongruent", list(c(same_prior,same_prior,1-same_prior)),
                                                 list(c(diff_prior,diff_prior,1-diff_prior))
 
                                   ))))%>%
  select(Speaker,age_num,Alignment,so,priorProbs,correct_inf)

```

### Noise parameter across age

```{r}
noisyModelPredWebppl <-'

var allData = dataFromR.ex3data

var model = function(){
  
  var noise = uniformDrift({a: 0, b: 1, width: 0.1})  

  var output = map(function(row){

    var modelPredictions = pragmaticListener({label: "dax", point: 2 }, row.priorProbs,row.so)

    var noisyModelPredictions = addNoise(modelPredictions, noise)

    observe(noisyModelPredictions, row.correct_inf)

    return  [row.age_num + "/" + row.Speaker + "/" + row.Alignment, Math.exp(noisyModelPredictions.score(1))]

}, allData)

 return extend(_.fromPairs(output), {noise: noise})

}
'
```

```{r}
noisy_model_pred<- webppl(
  program_code = paste(rsaUtils, rsaModel, noisyModelPredWebppl , sep='\n'),
  data =list(ex3data = ex3_data_param),
  data_var = "dataFromR",
  model_var = "model",
  chains = 4,
  cores = 4,
  inference_opts = list(method = "MCMC", samples = 2000, burn = 500, verbose = T)
)



posterior.noise <- noisy_model_pred %>%
  filter(Parameter %in% c("noise"))

ggplot(posterior.noise, aes(x = value))+
  geom_histogram()+
  facet_wrap(~Parameter, scales = 'free')



noisy_pred <- noisy_model_pred %>%
  filter(!(Parameter %in% c("noise"))) %>%
  separate(Parameter, into = c("age", "Speaker", "Alignment"), sep="/")%>%
  mutate( model = "noise parameter across age")%>%
  group_by(model, age,Alignment,Speaker) %>%
  summarise(mean = estimate_mode(value), 
            ci_lower = hdi_lower(value), 
            ci_upper =hdi_upper(value))%>%
  ungroup()%>%
  mutate(age = as.numeric(age))


```

### Developmental noise parameter

```{r}
developmentalNoisyModelPred <-'

var allData = dataFromR.ex3data

var model = function(){
  
  var noise_slope = uniformDrift({a: -2, b: 2, width: 0.2})
  var noise_int = uniformDrift({a: -2, b: 2, width: 0.2})    

  var output = map(function(row){

    var noise = logistic(noise_int + noise_slope * (row.age_num))

    var modelPredictions = pragmaticListener({label: "dax", point: 2 }, row.priorProbs,row.so)

    var noisyModelPredictions = addNoise(modelPredictions, noise)

    observe(noisyModelPredictions, row.correct_inf)

    return  [row.age_num + "/" + row.Speaker + "/" + row.Alignment, Math.exp(noisyModelPredictions.score(1))]

}, allData)

 return extend(_.fromPairs(output), {noise_int: noise_int, noise_slope: noise_slope})

}
'
```


```{r}
dev_noisy_model_pred<- webppl(
  program_code = paste(rsaUtils, rsaModel, developmentalNoisyModelPred , sep='\n'),
  data =list(ex3data = ex3_data_param),
  data_var = "dataFromR",
  model_var = "model",
  chains = 4,
  cores = 4,
  inference_opts = list(method = "MCMC", samples = 2000, burn = 500, verbose = T)
)

posterior.noise <- dev_noisy_model_pred %>%
  filter(Parameter %in% c("noise_int", "noise_slope"))

ggplot(posterior.noise, aes(x = value))+
  geom_histogram()+
  facet_wrap(~Parameter, scales = 'free')


dev_noisy_pred <- dev_noisy_model_pred %>%
  filter(!(Parameter %in% c("noise_int", "noise_slope"))) %>%
  separate(Parameter, into = c("age", "Speaker", "Alignment"), sep="/")%>%
  mutate( model = "developmental noise parameter")%>%
  group_by(model, age,Alignment,Speaker) %>%
  summarise(mean = estimate_mode(value), 
            ci_lower = hdi_lower(value), 
            ci_upper =hdi_upper(value))%>%
  ungroup()%>%
  mutate(age = as.numeric(age))


```

## Plot comparing noisy model and data by continous age
```{r comparison plot by age, echo= FALSE}

models <- bind_rows(
  pred,
  noisy_pred,
  dev_noisy_pred
)


p_data <- ex3_data %>%
  filter(trial != "filler1",
         trial != "filler2")%>%
  mutate(age_bin = age_num - 3)%>%
  group_by(Speaker, Alignment ,age_bin, subid)


ggplot(models)+
  #geom_jitter(data = p_data, aes(x = age_bin, y = correct_inf), width = .025,height = .025, alpha = .2)+
  geom_ribbon(aes(x = age, ymin = ci_lower, ymax = ci_upper, fill = model), alpha = .4) +
  geom_line(aes(x = age, y = mean, col = model), size = 1, alpha = 1, linetype = 1) + 
  geom_smooth(data = p_data, aes(x = age_num, y = correct_inf), col = "black", size = 0.6, method = "glm", method.args = list(family = "binomial"),  se = T,  alpha = .5, size = .4)+
  #geom_hline(yintercept = 0.5, lty=2)+
  labs(y="proportion more informative")+
  ylim(-0.05,1.05)+
  facet_grid(Speaker~Alignment)+
  theme_few()+
  scale_color_solarized()+
  scale_fill_solarized()

```

```{r}
data <- ex3_data %>%
  filter(trial != "filler1",
         trial != "filler2")%>%
  group_by(Speaker, Alignment ,subage) %>%
  summarize(k = sum(correct_inf), n = n())%>%
  ungroup() %>%
  mutate(a = 1 + k,
         b = 1 + n - k,
         Data_ci_lower  = qbeta(.025, a, b),
         Data_ci_upper = qbeta(.975, a, b),
         Data = (a-1)/(a+b-2))%>%
  select(-a,-b,-n,-k)

model <- models %>%
  mutate(age = ifelse(age<4,"3","4"))%>%
  group_by(model,Speaker,Alignment,age)%>%
  summarise(Model = mean(mean),
            Model_ci_lower =hdi_lower(mean) ,
            Model_ci_upper = hdi_upper(mean))
  

cor_plot <- model %>%
  ungroup()%>%
  mutate(Data = rep(data$Data,3),
         Data_ci_lower = rep(data$Data_ci_lower,3),
         Data_ci_upper  =rep( data$Data_ci_upper,3))


ggplot(data = cor_plot,aes(x = Model, y = Data, col = age)) +
  geom_abline(intercept = 0, slope = 1, lty = 2, alpha = 1, size = .5)+
  geom_point(size = 3)+
  geom_errorbar(aes(ymin = Data_ci_lower, ymax = Data_ci_upper),width = 0,size = .5)+
  geom_errorbarh(aes(xmin = Model_ci_lower, xmax = Model_ci_upper), height = 0,size = .5)+
  coord_fixed()+
  facet_grid(~model)+
  stat_cor(method = "pearson", label.x = 0.01, label.y = 0.99, aes(x = Model, y = Data), inherit.aes = F)+
  xlim(0,1)+ylim(0,1)+
  xlab("Model")+
  theme_few() + 
  scale_colour_solarized()
```

